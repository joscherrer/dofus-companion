// Code generated by gioui.org/cmd/svg2gio; DO NOT EDIT.

package assets

import "image/color"
import "math"
import "gioui.org/op"
import "gioui.org/op/clip"
import "gioui.org/op/paint"
import "gioui.org/f32"

var ops op.Ops

func argb(c uint32) color.NRGBA {
	return color.NRGBA{A: uint8(c >> 24), R: uint8(c >> 16), G: uint8(c >> 8), B: uint8(c)}
}

func rect(p *clip.Path, origin, size f32.Point) {
	p.MoveTo(origin)
	p.LineTo(origin.Add(f32.Pt(size.X, 0)))
	p.LineTo(origin.Add(size))
	p.LineTo(origin.Add(f32.Pt(0, size.Y)))
	p.Close()
}

func ellipse(p *clip.Path, center, radius f32.Point) {
	r := radius.X
	// We'll model the ellipse as a circle scaled in the Y
	// direction.
	scale := radius.Y / r

	// https://pomax.github.io/bezierinfo/#circles_cubic.
	const q = 4 * (math.Sqrt2 - 1) / 3

	curve := r * q
	top := f32.Point{X: center.X, Y: center.Y - r*scale}

	p.MoveTo(top)
	p.CubeTo(
		f32.Point{X: center.X + curve, Y: center.Y - r*scale},
		f32.Point{X: center.X + r, Y: center.Y - curve*scale},
		f32.Point{X: center.X + r, Y: center.Y},
	)
	p.CubeTo(
		f32.Point{X: center.X + r, Y: center.Y + curve*scale},
		f32.Point{X: center.X + curve, Y: center.Y + r*scale},
		f32.Point{X: center.X, Y: center.Y + r*scale},
	)
	p.CubeTo(
		f32.Point{X: center.X - curve, Y: center.Y + r*scale},
		f32.Point{X: center.X - r, Y: center.Y + curve*scale},
		f32.Point{X: center.X - r, Y: center.Y},
	)
	p.CubeTo(
		f32.Point{X: center.X - r, Y: center.Y - curve*scale},
		f32.Point{X: center.X - curve, Y: center.Y - r*scale},
		top,
	)
}

var Image_arrow_down struct {
	ViewBox struct{ Min, Max f32.Point }
	Call    op.CallOp
}

func init() {
	m := op.Record(&ops)
	Image_arrow_down.ViewBox.Min = f32.Pt(0, 0)
	Image_arrow_down.ViewBox.Max = f32.Pt(24, 24)
	{
		var p clip.Path
		p.Begin(&ops)
		p.MoveTo(f32.Pt(5.70711, 9.71069))
		p.CubeTo(f32.Pt(5.31658, 10.1012), f32.Pt(5.31658, 10.7344), f32.Pt(5.70711, 11.1249))
		p.LineTo(f32.Pt(10.5993, 16.0123))
		p.CubeTo(f32.Pt(11.3805, 16.7927), f32.Pt(12.6463, 16.7924), f32.Pt(13.4271, 16.0117))
		p.LineTo(f32.Pt(18.3174, 11.1213))
		p.CubeTo(f32.Pt(18.708, 10.7308), f32.Pt(18.708, 10.0976), f32.Pt(18.3174, 9.70708))
		p.CubeTo(f32.Pt(17.9269, 9.31655), f32.Pt(17.2937, 9.31655), f32.Pt(16.9032, 9.70708))
		p.LineTo(f32.Pt(12.7176, 13.8927))
		p.CubeTo(f32.Pt(12.3271, 14.2833), f32.Pt(11.6939, 14.2832), f32.Pt(11.3034, 13.8927))
		p.LineTo(f32.Pt(7.12132, 9.71069))
		p.CubeTo(f32.Pt(6.7308, 9.32016), f32.Pt(6.09763, 9.32016), f32.Pt(5.70711, 9.71069))
		spec := p.End()
		paint.FillShape(&ops, argb(0xff0f0f0f), clip.Outline{Path: spec}.Op())
	}
	Image_arrow_down.Call = m.Stop()
}

var Image_arrow_up struct {
	ViewBox struct{ Min, Max f32.Point }
	Call    op.CallOp
}

func init() {
	m := op.Record(&ops)
	Image_arrow_up.ViewBox.Min = f32.Pt(0, 0)
	Image_arrow_up.ViewBox.Max = f32.Pt(24, 24)
	{
		var p clip.Path
		p.Begin(&ops)
		p.MoveTo(f32.Pt(18.2929, 15.2893))
		p.CubeTo(f32.Pt(18.6834, 14.8988), f32.Pt(18.6834, 14.2656), f32.Pt(18.2929, 13.8751))
		p.LineTo(f32.Pt(13.4007, 8.98766))
		p.CubeTo(f32.Pt(12.6195, 8.20726), f32.Pt(11.3537, 8.20757), f32.Pt(10.5729, 8.98835))
		p.LineTo(f32.Pt(5.68257, 13.8787))
		p.CubeTo(f32.Pt(5.29205, 14.2692), f32.Pt(5.29205, 14.9024), f32.Pt(5.68257, 15.2929))
		p.CubeTo(f32.Pt(6.0731, 15.6835), f32.Pt(6.70626, 15.6835), f32.Pt(7.09679, 15.2929))
		p.LineTo(f32.Pt(11.2824, 11.1073))
		p.CubeTo(f32.Pt(11.673, 10.7168), f32.Pt(12.3061, 10.7168), f32.Pt(12.6966, 11.1073))
		p.LineTo(f32.Pt(16.8787, 15.2893))
		p.CubeTo(f32.Pt(17.2692, 15.6798), f32.Pt(17.9024, 15.6798), f32.Pt(18.2929, 15.2893))
		spec := p.End()
		paint.FillShape(&ops, argb(0xff0f0f0f), clip.Outline{Path: spec}.Op())
	}
	Image_arrow_up.Call = m.Stop()
}
